let c = 123 * if 23 then a else 3;


def e(arg, arg2) = 
	let val = arg*23 + if 3 then 12 else 100;
	val * 2;

// Array types allocated on the heap not on the stack, allocate some memory for these strucutres
let int[100]:myArr;
for (int i = 0; i < 100; i ++)
	myArr[i] = 100;

// This is a comment!
let finalVal = myNewFunction(1, 2, 3);

// Structs and types
// int, float, string, bool, char
type hello = {
	int:red;
	int:green;
	int:blue;
}
// Note that this is the same way we parse identifiers, with optional types
// <type>:<val> makes more sense for the user

// Here we construct a novel type with custom values
let type:zoo = 
	| AnimalZoo of int
	| Data of {
		int:numAnimals;
	  }
	| Name of string;
	| None

// These structures live on the heap, and must be freed
let hello:myColor = {
	red = 20;
	green = 200;
	blue = 1;
}

let type:myType = int;
// myType is a type, whose values have the same type as the int type, or typeof(100);

returning a structure will return a pointer to that structure. MyColor is a pointer to the actual record that lives on the heap. But how do we create this record and return it?

let int:hello(int:a, int:b) = a + b;
let bool:max(int:a, int:b) = if a < b then a else b;
let bool:theMax = max(1, 2);

let type:greater =
	| First
	| Second

type greater =
	| First
	| Second
return First;
// Cant have local type definitions which return values after which the type goes out of scope

def hello:getRed() {
	return {
		red = 255;
		green = 0;
		blue = 0;
	}
}
This function returns a pointer to a structure.
/* THOUGHTS

-- Type System
having primitive types and user defined types behaving seperately is not ideal. The inbuilt int and str types should behave consistently as do the types that users define.

We need a typeof inbuilt so we can check types. Types are basically variables.

The issue is that these should live on the heap, not the stack
Thus we need to have some sort of flyweight pattern

Perhaps have a wrapper defined, and placed in a central class table.
Have all types defined in its own lexical environment; For example, have some typedef in nested structures.

We should have symbol and type tables, which are seperate and don't have pointers. And then a lexical table manager which manages different contexts. This will allow for the compiler to navigate nested lexical scopes, having access to both symbol and type tables at once. Each lexical scope node.

These scope environment is global, used in fe AND mid.

Variables and functions are the same thing
They are both values

Having an abstraction layer over the provided LLVM types will allow for unification of all types with a custom format for accessing objects and their properties.

-- Scoping Rules
We use a stack structure to maintain scopes.

-- Mutable Variables
All mutable vars are placed in the entry block of the function. They must be initialized with a value.

In llvm ir, have all mutable variables allocated on the stack by default, using alloca. Then use load and store operations to modify this value. Use mem2reg pass to optimize.
In the symbol table, we store the memory of the stored variabe, so we can later load and store it. Automatically goes out of scope when we leave the function, so closures then become tricky to maintain.

Constants are basically global variables which are made invisible to the module.

-- Functions
Variables are named and handled according to the scoping table. This doesn't work for functions however.
Function mangling is necessary, but the access at the higher level language is managed by scoping tables, create artificial encapsulation. Artificial becuase it is enforced by the compiler, it is not actually encapsulated in the lower level generated code.

-- Closures
Returning a closure requires returning a function pointer of some kind. Say we have an outer function, in which an inner function is define. 

-- Classes, Objects

-- Ogranization
Parser should put names into the symbol table
It can put in some primitives as well
What about generics?
Variables are generics
It can put in some primitives as well
What about generics?
Variables are generics

Functions need a return type, and a list of parameter type values
return type needs to be checked with actual return type
*/

